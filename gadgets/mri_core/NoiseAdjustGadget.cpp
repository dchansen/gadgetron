#include "NoiseAdjustGadget.h"
#include "hoArmadillo.h"
#include "hoMatrix.h"
#include "hoNDArray_elemwise.h"
#include "hoNDArray_linalg.h"
#include "hoNDArray_reductions.h"
#include "io/primitives.h"
#include "log.h"
#include <boost/iterator/counting_iterator.hpp>
#ifdef USE_OMP
#include "omp.h"
#endif // USE_OMP

#ifndef _WIN32
#include <sys/stat.h>
#include <sys/types.h>
#endif // _WIN32

#include <boost/algorithm/string.hpp>
#include <boost/algorithm/string/split.hpp>

using namespace std::string_literals;
namespace bf = boost::filesystem;
namespace Gadgetron {
    namespace {

        template <class T> T value_or(const ISMRMRD::Optional<T>& opt, T default_value) {
            return opt ? *opt : default_value;
        }

        std::string generateMeasurementIdOfNoiseDependency(
            const std::string& noise_id, const std::string& measurement_id) {

            // TODO: Remove this hack. This hack addresses a problem with mislabeled noise dependency IDs generated by
            // the converter. We will keep this for a transition period while preserving backwards compatibility
            if (noise_id.find('_') == std::string::npos) {
                // find the scan prefix
                std::string measurementStr = measurement_id;
                size_t ind                 = measurement_id.find_last_of('_');
                if (ind != std::string::npos) {
                    measurementStr = measurement_id.substr(0, ind) + "_"s + noise_id;
                }

                return measurementStr;
            }

            return noise_id;
        }

        float bandwidth_from_header(const ISMRMRD::IsmrmrdHeader& header) {
            return value_or(header.acquisitionSystemInformation->relativeReceiverNoiseBandwidth, 0.793f);
        }

        bf::path generateNoiseDependencyFilePath(const std::string& measurement_id,
            const bf::path& noise_dependency_folder, const std::string& noise_dependency_prefix) {
            auto full_name_stored_noise_dependency
                = noise_dependency_folder / (noise_dependency_prefix + "_"s + measurement_id);

            return full_name_stored_noise_dependency;
        }

        struct NoiseCovariance {
            ISMRMRD::IsmrmrdHeader header;
            float noise_dwell_time_us;
            hoNDArray<std::complex<float>> noise_covariance_matrix;
        };

        Gadgetron::Core::optional<NoiseCovariance> loadNoiseCovariance(const bf::path& noise_dependency_file) {
            using namespace Core::IO;
            if (!bf::exists(noise_dependency_file))
                return Core::none;

            std::ifstream infile;
            infile.open(noise_dependency_file.c_str(), std::ios::in | std::ios::binary);
            if (!infile.good())
                return Core::none;

            // Read the XML header of the noise scan

            auto xml_str = read_string_from_stream<uint32_t>(infile);

            ISMRMRD::IsmrmrdHeader header;
            ISMRMRD::deserialize(xml_str.c_str(), header);

            auto noise_dwell_time_us = read<float>(infile);

            auto cov_matrix = read<hoNDArray<std::complex<float>>>(infile);

            return NoiseCovariance{ header, noise_dwell_time_us, cov_matrix };
        }

        std::string to_string(const std::vector<ISMRMRD::CoilLabel>& coils) {
            std::stringstream sstream;
            for (auto i = 0u; i < coils.size(); i++)
                sstream << "Coil " << i << " - " << coils[i].coilNumber << " - " << coils[i].coilName;
            return sstream.str();
        }

        // compare coil labels of noise and data
        // if number of channels are different, return false and order.size()==0
        // if any channels in noise cannot be found in data, return false and order.size()==0
        // if all channels in noise exist in data, but order is incorrect, return false, but  and order.size()==CHA
        // if all channels in nosie match channels in data, return true
        // order gives the matching order for src and dst coils
        // e.g. [2 1 0 3] means coil 0 of src matches coil 2 of dst etc.

        bool compare_coil_label(const std::vector<ISMRMRD::CoilLabel>& src_coils,
            const std::vector<ISMRMRD::CoilLabel>& dst_coils, std::vector<size_t>& order_in_src) {
            auto coil_name_comparer
                = [](const auto& coil1, const auto& coil2) { return coil1.coilName == coil2.coilName; };
            bool labels_match = std::equal(
                src_coils.begin(), src_coils.end(), dst_coils.begin(), dst_coils.end(), coil_name_comparer);

            if (labels_match)
                return labels_match;

            if (!is_permutation(
                    src_coils.begin(), src_coils.end(), dst_coils.begin(), dst_coils.end(), coil_name_comparer))
                return false;

            order_in_src = std::vector<size_t>(dst_coils.size(), 0);
            std::iota(order_in_src.begin(), order_in_src.end(), 0);

            for (size_t d = 0u; d < order_in_src.size(); d++) {
                if (coil_name_comparer(dst_coils[d], src_coils[d]))
                    continue;
                auto coil_it    = std::find_if(src_coils.begin(), src_coils.end(),
                    [&](const auto& coil) { return coil_name_comparer(coil, dst_coils[d]); });
                order_in_src[d] = std::distance(src_coils.begin(), coil_it);
            }

            return labels_match;
        }

        hoNDArray<std::complex<float>> mask_channels(
            hoNDArray<std::complex<float>> noise_prewhitener_matrix, const std::vector<size_t>& scale_only_channels) {
            // Mask out scale  only channels
            size_t c                  = noise_prewhitener_matrix.get_size(0);
            std::complex<float>* dptr = noise_prewhitener_matrix.data();
            for (auto ch : scale_only_channels) {
                for (size_t i = 0; i < c; i++) {
                    for (size_t j = 0; j < c; j++) {
                        if ((i == ch || j == ch) && (i != j)) { // zero if scale only and not on diagonal
                            dptr[i * c + j] = std::complex<float>(0.0, 0.0);
                        }
                    }
                }
            }
            return std::move(noise_prewhitener_matrix);
        }

        hoNDArray<std::complex<float>> computeNoisePrewhitener(
            const hoNDArray<std::complex<float>>& noise_covariance_matrix) {
            //            GDEBUG("Noise dwell time: %f\n", noise_dwell_time_us_);
            //            GDEBUG("receiver_noise_bandwidth: %f\n", receiver_noise_bandwidth_);

            auto noise_prewhitener_matrix = noise_covariance_matrix;
            size_t c                      = noise_prewhitener_matrix.get_size(0);
            float v                       = Gadgetron::asum(noise_covariance_matrix);
            if (v <= 0) {
                GDEBUG("Accumulated noise prewhitener is empty\n");
                for (size_t cha = 0; cha < c; cha++) {
                    noise_prewhitener_matrix(cha, cha) = 1;
                }
            } else {
                // Cholesky and invert lower triangular
                arma::cx_fmat noise_covf = as_arma_matrix(noise_prewhitener_matrix);
                noise_covf               = arma::inv(arma::trimatu(arma::chol(noise_covf)));
            }

            return noise_prewhitener_matrix;
        }

        std::vector<size_t> find_scale_only_channels(
            const std::string& scale_only_channels_by_name, const std::vector<ISMRMRD::CoilLabel>& coillabels) {
            if (scale_only_channels_by_name.empty())
                return {};
            // Let's figure out if some channels are "scale_only"
            const std::string& uncomb_str = scale_only_channels_by_name;
            GDEBUG("SCALE ONLY: %s\n", uncomb_str.c_str());
            std::vector<std::string> uncomb;
            boost::split(uncomb, uncomb_str, boost::is_any_of(","));
            std::vector<size_t> scale_only_channels;

            for (unsigned int i = 0; i < uncomb.size(); i++) {
                std::string ch = boost::algorithm::trim_copy(uncomb[i]);
                if (std::find_if(
                        coillabels.begin(), coillabels.end(), [&](const auto& coil) { return ch == coil.coilName; })
                    != coillabels.end())
                    scale_only_channels.push_back(i);
            }
            return scale_only_channels;
        }

        hoNDArray<std::complex<float>> reorder_noise_channels(
            hoNDArray<std::complex<float>> noise_covariance, const std::vector<size_t>& coil_order) {
            // check whether to switch channel order
            auto CHA = noise_covariance.get_size(0);
            if ((coil_order.size() != CHA)
                || std::equal(coil_order.begin(), coil_order.end(), boost::counting_iterator<size_t>(0)))
                return std::move(noise_covariance);

            GDEBUG_STREAM("Require to reorder the noise covariance matrix to match the data ... ");
            hoNDArray<std::complex<float>> noise_covariance_reordered = noise_covariance;

            // switch row
            for (size_t n = 0; n < CHA; n++) {
                noise_covariance_reordered(n, slice) = noise_covariance(coil_order[n], slice);
            }

            // switch column
            for (size_t m = 0; m < CHA; m++) {
                noise_covariance(slice, m) = noise_covariance_reordered(slice, coil_order[m]);
            }

            return std::move(noise_covariance);
        }


       float calculate_scale_factor(float acquisition_dwell_time_us, float noise_dwell_time_us, float receiver_noise_bandwidth ){
            float noise_bw_scale_factor;
           if ((noise_dwell_time_us == 0.0f) || (acquisition_dwell_time_us == 0.0f)) {
               noise_bw_scale_factor = 1.0f;
           } else {
               noise_bw_scale_factor = std::sqrt(
                   2.0f * acquisition_dwell_time_us / noise_dwell_time_us * receiver_noise_bandwidth);
           }
           return noise_bw_scale_factor;
        }
    }

    NoiseAdjustGadget::NoiseAdjustGadget(const Core::Context& context, const Core::GadgetProperties& props)
        : Core::ChannelGadget<Core::Acquisition>(context, props)
        , current_ismrmrd_header(context.header)
        , receiver_noise_bandwidth{ bandwidth_from_header(context.header) } {

        GDEBUG("Folder to store noise dependencies is %s\n", noise_dependency_folder.c_str());
        GDEBUG("NoiseAdjustGadget::perform_noise_adjust_ is %d\n", perform_noise_adjust);
        GDEBUG("NoiseAdjustGadget::pass_nonconformant_data_ is %d\n", pass_nonconformant_data);
        GDEBUG("receiver_noise_bandwidth_ is %f\n", receiver_noise_bandwidth);

#ifdef USE_OMP
        omp_set_num_threads(1);
#endif // USE_OMP
        if (!current_ismrmrd_header.measurementInformation)
            return;
        // find the measurementID of this scan

        auto measurement_id = value_or(current_ismrmrd_header.measurementInformation->measurementID, ""s);
        GDEBUG("Measurement ID is %s\n", measurement_id.c_str());

        const auto& measurementDependency = current_ismrmrd_header.measurementInformation->measurementDependency;
        auto val                          = std::find_if(measurementDependency.begin(), measurementDependency.end(),
            [](const auto& dependency) { return std::tolower(dependency.dependencyType) == "noise"; });

        // find the noise depencies if any
        if (val == measurementDependency.end())
            return;

        auto noise_dependency = *val;
        GDEBUG("Measurement ID of noise dependency is %s\n", noise_dependency.measurementID.c_str());

        auto full_name_stored_noise_dependency = generateNoiseDependencyFilePath(
            generateMeasurementIdOfNoiseDependency(noise_dependency.measurementID, measurement_id),
            noise_dependency_folder, noise_dependency_prefix);
        GDEBUG("Stored noise dependency is %s\n", full_name_stored_noise_dependency.c_str());

        auto noiseCovariance = loadNoiseCovariance(full_name_stored_noise_dependency);
        // try to load the precomputed noise prewhitener
        if (!noiseCovariance) {
            GDEBUG("Stored noise dependency is NOT found : %s\n", full_name_stored_noise_dependency.c_str());
        } else {
            GDEBUG("Stored noise dependency is found : %s\n", full_name_stored_noise_dependency.c_str());
            GDEBUG("Stored noise dwell time in us is %f\n", noiseCovariance->noise_dwell_time_us);
            size_t CHA = noiseCovariance->noise_covariance_matrix.get_size(0);
            GDEBUG("Stored noise channel number is %d\n", CHA);

            if (noiseCovariance->header.acquisitionSystemInformation) {
                GDEBUG_STREAM("Noise coil info: ");
                GDEBUG_STREAM(to_string(noiseCovariance->header.acquisitionSystemInformation->coilLabel));

                GDEBUG_STREAM("Data coil info: ");
                GDEBUG_STREAM(to_string(current_ismrmrd_header.acquisitionSystemInformation->coilLabel));

                std::vector<size_t> coil_order_of_data_in_noise;
                bool labels_match = compare_coil_label(noiseCovariance->header.acquisitionSystemInformation->coilLabel,
                    current_ismrmrd_header.acquisitionSystemInformation->coilLabel, coil_order_of_data_in_noise);

                if (!labels_match) {
                    // if number of channels in noise is different than data
                    // or
                    // if any channels in noise do not exist in data
                    if (CHA != current_ismrmrd_header.acquisitionSystemInformation->coilLabel.size()) {
                        GDEBUG("Noise and measurement have different number of coils\n");
                    } else {
                        if (coil_order_of_data_in_noise.size() == CHA) {
                            GWARN_STREAM("Noise and meansurement have different coils, but could be reordered ... ");
                        } else {
                            GWARN_STREAM("Noise and meansurement have different coils and cannot be reordered ... ");
                        }
                    }
                }

            } else if (current_ismrmrd_header.acquisitionSystemInformation) {
                GERROR("Noise ismrmrd header does not have acquisition system information but current header "
                       "does\n");
            }

            //                    number_of_noise_samples_ = 1; // When we load the matrix, it is already
            //                    scaled.
        }
    }

    static bool is_noise(const Core::Acquisition& acq) {
        return std::get<ISMRMRD::AcquisitionHeader>(acq).isFlagSet(ISMRMRD::ISMRMRD_ACQ_IS_NOISE_MEASUREMENT);
    }

    static void process_with_prewhitening(Core::InputChannel<Core::Acquisition>& input, Core::OutputChannel& output,
        const hoNDArray<std::complex<float>>& prewhitener, bool pass_nonconformant_data) {

        for (auto acq : input) {
            if (is_noise(acq))
                continue;

            auto& data = std::get<hoNDArray<std::complex<float>>>(acq);
            if (data.get_size(1) == prewhitener.get_size(0)) {
                auto tmp = data;
                gemm(data, tmp, prewhitener);
                output.push(std::move(acq));
            } else if (pass_nonconformant_data) {
                output.push(std::move(acq));
            } else {
                throw std::runtime_error("Input data has different number of channels from noise data");
            }
        }
    }
    namespace {

        struct NoiseGatherer {
            hoNDArray<std::complex<float>> tmp_covariance;
            size_t number_of_samples           = 0;
            const bool pass_nonconformant_data = false;
            std::vector<size_t> data_order;
        };

        struct Prewhitener {
            const hoNDArray<std::complex<float>> prewhitening_matrix;
            const bool pass_nonconformant_data = false;
        };

        using NoiseHandler = Core::variant<NoiseGatherer, Prewhitener>;

        NoiseHandler prewhiten(Prewhitener& pw, Core::Acquisition& acq) {
            auto& data = std::get<hoNDArray<std::complex<float>>>(acq);
            if (data.get_size(1) == pw.prewhitening_matrix.get_size(0)) {
                auto tmp = data;
                gemm(data, tmp, pw.prewhitening_matrix);
            } else if (!pw.pass_nonconformant_data) {
                throw std::runtime_error("Input data has different number of channels from noise data");
            }
            return std::move(pw);
        }

        void add_noise(Prewhitener& pw, const Core::Acquisition& acq) {}

        void add_noise(NoiseGatherer& ng, const Core::Acquisition& acq) {

            auto& data = std::get<hoNDArray<std::complex<float>>>(acq);
            hoNDArray<std::complex<float>> readout(data);
            auto channels = std::get<ISMRMRD::AcquisitionHeader>(acq).active_channels;
            if (ng.tmp_covariance.empty()) {
                ng.tmp_covariance = hoNDArray<std::complex<float>>(channels, channels);
                std::fill(ng.tmp_covariance.begin(), ng.tmp_covariance.end(), std::complex<float>(0));
            }

            gemm(ng.tmp_covariance, readout, true, data, false);
            ng.number_of_samples += data.get_size(0);
        }

        NoiseHandler prewhiten(NoiseGatherer& ng, const Core::Acquisition& acq) {
            if (ng.number_of_samples == 0) return std::move(ng);

            ng.tmp_covariance = reorder_noise_channels(ng.tmp_covariance, ng.data_order);
            ng.tmp_covariance /= std::complex<float>(ng.number_of_samples+1);

            auto prewhitening_matrix = computeNoisePrewhitener(ng.tmp_covariance);
            return Prewhitener{prewhitening_matrix,ng.pass_nonconformant_data};
            // Do STUFF
        }

        void add_noise(NoiseHandler& nh, const Core::Acquisition& acq) {
            Core::visit([&](auto& vs) { add_noise(vs, acq); }, nh);
        }

        NoiseHandler prewhiten(NoiseHandler& nh, const Core::Acquisition& acq) {
            return Core::visit([&](auto& vs) { return prewhiten(vs, acq); }, nh);
        }

    }

    void NoiseAdjustGadget::process(Core::InputChannel<Core::Acquisition>& input, Core::OutputChannel& output) {


    }

    GADGETRON_GADGET_EXPORT(NoiseAdjustGadget)

} // namespace Gadgetron
